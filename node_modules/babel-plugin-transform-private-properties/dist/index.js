'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = function (_ref) {
  var t = _ref.types;


  return {
    visitor: {
      Program: function Program(path) {
        path.traverse({
          Class: function Class(path) {
            var insertPath = path.parentPath.type === 'ExportNamedDeclaration' || path.parentPath.type === 'ExportDefaultDeclaration' ? path.parentPath : path;
            var isSubClass = !!path.node.superClass;
            var constructor = void 0;
            var props = [];
            var body = path.get("body");
            var privateDecorator = null;
            var instanceBody = [];
            var methods = [];
            var refs = {};
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = body.get("body")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var subPath = _step.value;

                if (subPath.isClassMethod({ kind: "constructor" })) {
                  constructor = subPath;
                } else if (subPath.isClassMethod() && (privateDecorator = findPrivateDecorator(subPath.node)) !== false) {
                  var id = refs[subPath.node.key.name] || path.scope.generateUidIdentifier(subPath.node.key.name);
                  insertPath.insertBefore(t.variableDeclaration('var', [t.variableDeclarator(id, t.newExpression(t.Identifier('WeakMap'), []))]));
                  subPath.node.decorators.splice(privateDecorator, 1);
                  // move into constructor

                  refs[subPath.node.key.name] = id;
                  methods.push(subPath);
                } else if (subPath.isClassProperty() && subPath.node.decorators && subPath.node.decorators.length > 0) {
                  var propNode = subPath.node;
                  var _privateDecorator = findPrivateDecorator(propNode);
                  var _id = refs[propNode.key.name] || path.scope.generateUidIdentifier(propNode.key.name);
                  if (_privateDecorator === false) continue;
                  insertPath.insertBefore(t.variableDeclaration('var', [t.variableDeclarator(_id, t.newExpression(t.Identifier('WeakMap'), []))]));
                  refs[propNode.key.name] = _id;
                  if (propNode.value) {
                    instanceBody.push(t.expressionStatement(t.callExpression(t.memberExpression(_id, t.Identifier('set')), [t.thisExpression(), propNode.value])));
                  }
                  subPath.remove();
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            if (instanceBody.length) {
              if (!constructor) {
                var newConstructor = t.classMethod("constructor", t.identifier("constructor"), [], t.blockStatement([]));
                if (isSubClass) {
                  newConstructor.params = [t.restElement(t.identifier("args"))];
                  newConstructor.body.body.push(t.returnStatement(t.callExpression(t.super(), [t.spreadElement(t.identifier("args"))])));
                }

                var _body$unshiftContaine = body.unshiftContainer("body", newConstructor);

                var _body$unshiftContaine2 = _slicedToArray(_body$unshiftContaine, 1);

                constructor = _body$unshiftContaine2[0];
              }
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                var _loop = function _loop() {
                  var node = _step2.value;

                  node.traverse({
                    ThisExpression: function ThisExpression(path) {
                      handleRefItems(t, node, path, refs, t.thisExpression(), []);
                    }
                  });
                  instanceBody.push(t.expressionStatement(t.callExpression(t.memberExpression(refs[node.node.key.name], t.Identifier('set')), [t.thisExpression(), t.callExpression(t.memberExpression(t.functionExpression(t.Identifier(''), node.node.params, node.node.body), t.Identifier('bind')), [t.thisExpression()])])));
                  node.remove();
                };

                for (var _iterator2 = methods[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  _loop();
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }

              methods = [];
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                var _loop2 = function _loop2() {
                  var node = _step3.value;

                  node.traverse({
                    ThisExpression: function ThisExpression(path) {
                      handleRefItems(t, node, path, refs, t.thisExpression(), []);
                    }
                  });
                };

                for (var _iterator3 = body.get("body")[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  _loop2();
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }

              if (isSubClass) {
                var Supers = [];
                constructor.traverse({
                  Super: function Super(path) {
                    if (path.parentPath.isCallExpression({ callee: path.node })) {
                      this.push(path.parentPath);
                    }
                  }
                }, Supers);
                var _iteratorNormalCompletion4 = true;
                var _didIteratorError4 = false;
                var _iteratorError4 = undefined;

                try {
                  for (var _iterator4 = Supers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var Super = _step4.value;

                    Super.insertAfter(instanceBody);
                  }
                } catch (err) {
                  _didIteratorError4 = true;
                  _iteratorError4 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                      _iterator4.return();
                    }
                  } finally {
                    if (_didIteratorError4) {
                      throw _iteratorError4;
                    }
                  }
                }
              } else {
                constructor.get("body").unshiftContainer("body", instanceBody);
              }
            }
          }
        });
      }
    }
  };
};

function cleanJSON() {
  for (var _len = arguments.length, fields = Array(_len), _key = 0; _key < _len; _key++) {
    fields[_key] = arguments[_key];
  }

  var objs = [];
  var fields = ['loc', 'parent', 'hub', 'contexts', 'opts', 'parentPath', 'container', 'parentKey', 'parentBlock'].concat(fields);
  return function (k, v) {
    if (fields.indexOf(k) >= 0) return "[Object]";
    if (objs.indexOf(v) >= 0) return "[Circular Reference]";
    if ((typeof v === 'undefined' ? 'undefined' : _typeof(v)) === _typeof({}) || (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === _typeof([])) objs.push(v);
    return v;
  };
}

function handleRefItems(t, node, path, refs, refExp, known_vars) {
  if (path.parentPath.type === 'MemberExpression') {
    if (!refs[path.parent.property.name]) return;
    if (path.parentPath.parentPath.type == "AssignmentExpression") {
      if (path.parentPath.parent.left.type == "MemberExpression") {
        // console.log("Writing setter ",path.parentPath.parent.left.property.name)
        var id = refs[path.parentPath.parent.left.property.name] || path.scope.generateUidIdentifier(path.parentPath.parent.left.property.name);
        path.parentPath.parentPath.parentPath.replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(id, t.Identifier('set')), [path.node, path.parentPath.parent.right])));
      } else {
        // console.log("Writing getter ",path.parentPath.parent.left.property.name)
        var _id2 = refs[path.parent.property.name] || path.scope.generateUidIdentifier(path.parent.property.name);

        path.parentPath.replaceWith(t.callExpression(t.memberExpression(_id2, t.Identifier('get')), [refExp]));
      }
    } else {
      // console.log("Writing getter ",path.parent.property.name)
      var _id3 = refs[path.parent.property.name] || path.scope.generateUidIdentifier(path.parent.property.name);
      path.parentPath.replaceWith(t.callExpression(t.memberExpression(_id3, t.Identifier('get')), [refExp]));
    }
  } else {
    // TODO: Handle non "var" assignment. if "x=this" and x is not defined in a "var" then following it fails.
    if (path.parent.type == "AssignmentExpression") {
      if (path.scope.hasOwnBinding(path.parent.left.name)) {
        node.traverse({
          ReferencedIdentifier: function ReferencedIdentifier(path) {
            if (this.scope.hasOwnBinding(path.node.name) && known_vars.indexOf(path.node.name) == -1) {
              known_vars.push(path.node.name);
              handleRefItems(t, node, path, refs, path.node, known_vars);
            }
          }
        }, {
          scope: path.parentPath.scope
        });
      } else {
        var _id4 = path.parent.left;
        console.log("Traversing", _id4);
        node.traverse({
          ReferencedIdentifier: function ReferencedIdentifier(p) {
            console.log(JSON.stringify(p.parent, cleanJSON(), 4));
            if (path.node.name !== this.left.name && path.node.name !== this.right.name) return;
            handleRefItems(t, node, p, refs, p.node, known_vars);
          }
        }, {
          scope: path.scope,
          left: path.parent.left,
          right: path.parent.right
        });
      }
    } else if (path.parent.type == "VariableDeclarator") {
      node.traverse({
        ReferencedIdentifier: function ReferencedIdentifier(path) {
          if (this.scope.hasOwnBinding(path.node.name)) {
            // known_vars.push(path.node.name);
            handleRefItems(t, node, path, refs, path.node, known_vars);
          }
        }
      }, {
        scope: path.parentPath.scope
      });
    }
  }
}

function findPrivateDecorator(node) {
  var idx = 0;
  return (node.decorators || []).some(function (decorator) {
    return decorator.expression.name === 'Private' || ++idx && false;
  }) ? idx : false;
}

function deleteDecorators(klass, decorators) {
  decorators.forEach(function (decorator) {
    var index = klass.decorators.indexOf(decorator);
    if (index >= 0) {}
  });
}
module.exports = exports['default'];